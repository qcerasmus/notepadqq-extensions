/// <reference path="types/node.d.ts" />
var net = require('net');
var DataChannel = (function () {
    function DataChannel(socketPath, messageCallback, connectedCallback) {
        this._buffer = new Buffer(0);
        this._client = net.connect(socketPath, connectedCallback);
        this._client.on('data', function (data) {
            var totalData = null;
            if (data instanceof Buffer) {
                totalData = Buffer.concat([this._buffer, data]);
            }
            else {
                totalData = Buffer.concat([this._buffer, new Buffer(data.toString())]);
            }
            var messages = this._splitBuffer(totalData, new Buffer("\n"), false);
            // messages can be an array like the following ones:
            //     [msg1, msg2, ..., msgn, ""] => we received n complete messages.
            //     [msg1, msg2, ..., msgn] => we received n-1 complete messages, and an incomplete one.
            for (var i = 0; i < messages.length - 1; i++) {
                messageCallback(JSON.parse(messages[i].toString()));
            }
            this._buffer = messages[messages.length - 1];
        }.bind(this));
    }
    DataChannel.prototype.sendMessage = function (msg) {
        this._client.write(JSON.stringify(msg) + "\n");
    };
    DataChannel.prototype._splitBuffer = function (buf, splitBuf, includeDelim) {
        var search = -1;
        var lines = [];
        var move = includeDelim ? splitBuf.length : 0;
        while ((search = this._bufferIndexOf(buf, splitBuf)) > -1) {
            lines.push(buf.slice(0, search + move));
            buf = buf.slice(search + splitBuf.length, buf.length);
        }
        lines.push(buf);
        return lines;
    };
    DataChannel.prototype._bufferIndexOf = function (buf, search, offset) {
        if (offset === void 0) { offset = 0; }
        var m = 0;
        var s = -1;
        for (var i = offset; i < buf.length; ++i) {
            if (buf[i] == search[m]) {
                if (s == -1)
                    s = i;
                ++m;
                if (m == search.length)
                    break;
            }
            else {
                s = -1;
                m = 0;
            }
        }
        if (s > -1 && buf.length - s < search.length)
            return -1;
        return s;
    };
    return DataChannel;
})();
module.exports = DataChannel;
//# sourceMappingURL=data_channel.js.map